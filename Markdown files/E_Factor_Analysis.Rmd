---
title: "Exploratory_Factor_Analysis: random feature selection"
author: "Evariste"
date: "2022-10-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Exploratory factor analysis on the dataset MTBLS28 - Non-invasive urinary metabolomic profiling identifies diagnostic and prognostic markers in lung cancer

Load libraries
```{r}
library(psych)
library(EFAtools)
```


## Read files
File with patient race, gender, smoking status etc.
```{r s_mtbls28}
s_mtbls28 = read.table(file = 'MTBLS28_Lung-cancer/s_mtbls28.txt', sep = '\t', header = TRUE)
print("shape of s_mtbls28:")
dim(s_mtbls28)
```

Metabolite data for negative patients
```{r}
m_mtbls28_NEG = read.table(file = 'MTBLS28_Lung-cancer/m_mtbls28_NEG_v2_maf.tsv', sep = '\t', header = TRUE)
print("shape of m_mtbls28_NEG:")
dim(m_mtbls28_NEG)
```

Metabolite data for positive patients
```{r}
m_mtbls28_POS = read.table(file = 'MTBLS28_Lung-cancer/m_mtbls28_POS_v2_maf.tsv', sep = '\t', header = TRUE)
print("shape of m_mtbls28_POS:")
dim(m_mtbls28_POS)
```


Add metabolite identification: concatenate mtbls28 with the row id
```{r}
m_mtbls28_NEG$metabolite_identification = paste("mtbls28", seq(1, nrow(m_mtbls28_NEG)), sep="_")
```

Only keep columns needed
```{r}
rawdata_neg =  cbind(m_mtbls28_NEG$metabolite_identification, m_mtbls28_NEG[,22:ncol(m_mtbls28_NEG)])
#rename first column
names(rawdata_neg)[names(rawdata_neg) == "m_mtbls28_NEG$metabolite_identification"] <- "metabolite_identification"
print("shape of rawdata_neg:")
dim(rawdata_neg)
```

Reshape - transpose the dataframe 
```{r}
#define row names
new_col = rawdata_neg$metabolite_identification
row.names(rawdata_neg) = new_col
#Transpose
data_neg = t(rawdata_neg)
print("shape of data_neg:")
dim(data_neg)
```

```{r}
to_remove = "metabolite_identification"
#Remove metabolite_identification row
data_neg = as.data.frame(data_neg[!(row.names(data_neg) %in% to_remove),])
#Add lung cancer column
#data_neg$lung_cancer = 0
print("shape of data_neg:")
dim(data_neg)
```

```{r}
#Transform row name to colum
library("dplyr")
data_neg = tibble::rownames_to_column(data_neg, "Sample Name")
print("shape of data_neg:")
dim(data_neg)
```


```{r}
length(colnames(rawdata_neg))
length(colnames(rawdata_neg)[-1])
```



```{r}
#neg_data = merge(s_mtbls28, a_mtbls28_NEG, by="Sample.Name")
```


Sandbox
```{r eval=FALSE, include=FALSE}
folder = "D:/Research project/data/MTBLS28/ISATab/MTBLS28/"
a_MTBLS28_NEG_metabolite = read.table(file = paste(folder, "a_MTBLS28_NEG_metabolite_profiling_mass_spectrometry.txt", sep=""), sep = '\t', header = TRUE)
```


```{r}
paste("abd", "efg", sep = '')
```

```{r}
sample(2:67, 2)
```


## Problem formulation: Explore factors that may exist in the dataset
We search for latent pattern in the data which can classify properly on smoking status, gender, race or illness (pos/neg)

### Step 1. Appropriateness of factor analysis: Check if it exists some correlations among variables

#### Sample size
Should be 4 or 5 times the variables.
```{r}
#We cannot use all variables as the dataset is small
dim(data_neg[,-1]) #remove "sample name" column
```
Check there is no missing value
```{r}
sum(is.na(data_neg))
```
Let pick random 200 columns
```{r}
set.seed(2022)
variableSize = 200
colEfa = sample(2:ncol(data_neg), variableSize)
data_neg_fa = cbind(data_neg[,1], data_neg[,colEfa])
#rename first column
data_neg_fa = rename(data_neg_fa, "sample Name" = "data_neg[, 1]")
print("shape of neg data for factor analysis:")
dim(data_neg_fa)
```

Convert to numeric
```{r}
colVar = 2:ncol(data_neg_fa)
data_neg_fa[ , colVar] <- apply(data_neg_fa[ , colVar], 2,               function(x) as.numeric(x))
typeof(data_neg_fa[, 2])
```


#### Kaiser-Mayer-Olkin (KMO) measure of sampling adequacy
Expected value of KMO index should be greater than 0.7: smaller than 0.5 is unacceptable.
```{r}

```

```{r}
EFAtools::KMO(data_neg_fa[,-1])
```


#### Bartlett's test of Spericity: examine the hypothesis that variables are uncorrelated in the population.
If variables are uncorrelated this means FA is not appropriate (will not make sense)
Expected value of r should be smaller than 0.05: means data does not produce an identity matrix
```{r}
EFAtools::BARTLETT(data_neg_fa[,-1])
```

#### Communality: proportion of variance explained by the common factors.
Small values indicate variables that do not fit well with the factor. Index smaller that 0.5 should be removed.
Question: can be kept as a specific factor ?
```{r}

```


### Step 2. Factoring technique
Principal component method

### Step 3. Decision according to the number of factors
Expected number of factors: Cumulative factors explaining 60% - 70% of variance should be retained in the model
```{r eval=FALSE, include=FALSE}
N_FACTORS(data_neg_fa[,-1], method = "ULS")
```


#### Percentage of variance criteria
percentage of variance that can be attributed to each specific factor relative to the total variance in all the factors.
Base on the concept of cumulative percentage of variance
```{r}

```


#### Scree plot
The eigen values represents the total variance explained by each factor
The number of factors is equal to the number of eigen values greater than 1.
Use the scree plot: plot eigenvalues and factor number and look at the elbow
```{r}

```


### Step 4. Rotation factor (method)
A rotation is required because the original factor model may be mathematically correct but may be difficult in terms of interpretation.
If various factors have a high loading on the same variable, then interpretation will be extremly difficult.
The main objective of rotation is to produce a relatively simple structure in which there may be a high factor loading on one factor and low factor loading on all others factors.

#### Varimax (most common method used)
Minimizes the correlation between factors; makes it possible to identify a variable with a factor.
Return factors that are orthogonal
```{r}
res_efa_18 = EFA(data_neg_fa[,-1], n_factors = 18, rotation = "varimax", type = "EFAtools")
```

Model averaging
```{r eval=FALSE, include=FALSE}
EFA_AV <- EFA_AVERAGE(data_neg_fa[,-1], n_factors = 18, rotation = "varimax", averaging = "mean", show_progress = TRUE)
```


Compare two rotation techniques
```{r eval=FALSE, include=FALSE}
COMPARE(
  EFA(data_neg_fa[,-1], n_factors = 18, rotation = "varimax", type = "EFAtools")$rot_loadings,
  EFA(data_neg_fa[,-1], n_factors = 18, rotation = "promax", type = "EFAtools")$rot_loadings
)
```


#### Direct Oblimin (DO)
Factors are allowed to be correlated

#### Factor loadings: factor-variable correlation
Correlations between the variables and the factors
Should be greater than 0.5
```{r}
?EFA
```


#### Factor matrix
contains the factor loading of all the variables on all the factors extracted
```{r}
?EFA_AVERAGE
```


### Step 5. Model fit
The difference between the reproduced and observed correlation should be small (< 0.05) ?
Question: how to reproduce the degree of correlation ? Reproduced commonalities

### Step 6. Interpretation

# Classification with factors: target variable gender

Diagram factor
```{r}
loads = res_efa_18$rot_loadings

fa.diagram(loads[6:15,])
```

